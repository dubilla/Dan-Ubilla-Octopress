<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web-development | Dan Ubilla]]></title>
  <link href="http://danubilla.com/blog/categories/web-development/atom.xml" rel="self"/>
  <link href="http://danubilla.com/"/>
  <updated>2016-03-12T11:46:56-05:00</updated>
  <id>http://danubilla.com/</id>
  <author>
    <name><![CDATA[Dan Ubilla]]></name>
    <email><![CDATA[dan.ubilla@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Active Support Presence and the Single Line Method]]></title>
    <link href="http://danubilla.com/blog/web-development/activesupport-presence.html"/>
    <updated>2016-02-14T15:00:00-05:00</updated>
    <id>http://danubilla.com/blog/web-development/activesupport-presence</id>
    <content type="html"><![CDATA[<p>Ruby and Rails are both built to help us write concise, meaningful code. One pattern I constantly find myself writing is a method that returns one thing, if it exists, or a default value. This can work well upfront, but it takes a little more care if the case gets any more complex. Fortunately, Rails has just the trick to keep the more complex case nice and lean in its ActiveSupport gem.</p>

<!-- more -->


<p>Let&rsquo;s look at an example that works without Rails.</p>

<p><code>ruby
def title
  label || 'New Page'
end
</code></p>

<p>The above looks great. It will return label, if it exists, or it falls back to returning &lsquo;New Page&rsquo;. I&rsquo;m pretty thrilled with it. But what if we need to <code>titleize</code> the label?</p>

<p><code>ruby
def title
  label.titleize || 'New Page'
end
</code></p>

<p>Unfortunately, the above will throw an error if <code>label</code> is nil. That kind of defeats the purpose of the conditional in the first place. At this point, it&rsquo;d be easy to toss away our desire for concisement and write the following:</p>

<p>``` ruby
def title
  if label.present?</p>

<pre><code>label.titleize
</code></pre>

<p>  else</p>

<pre><code>'New Page'
</code></pre>

<p>  end
end
```</p>

<p>Our new method will work. But how can we leverage Rails to make our method a little sharper? ActiveSupport comes with a <code>#presence</code> method that returns the original object, if it exists, or <code>nil</code> otherwise. Let&rsquo;s see it in action.</p>

<p><code>ruby
def title
  label.titleize.presence || 'New Page'
end
</code></p>

<p>Boom! Our method is nice, lean, and readable. <code>#presence</code> is the secret to manipulating and returning a variable before it exists or falling back to a default.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularUI Router and Injecting $state vs $stateParams]]></title>
    <link href="http://danubilla.com/blog/web-development/angularui-router-and-injecting-state-vs-stateparams.html"/>
    <updated>2016-01-31T19:31:00-05:00</updated>
    <id>http://danubilla.com/blog/web-development/angularui-router-and-injecting-state-vs-stateparams</id>
    <content type="html"><![CDATA[<p>AngularUI Router is the de facto routing library in the Angular world. It takes the traditional routing mechanisms, and builds a subtle, but brilliant abstraction upon them. Instead of merely listening for requests at a set of URLs, it creates the concept of a set of states, each one configurable with an optional URL. This abstraction allows for flexibility when refactoring routes, but most interestingly, it creates the concept of a current state and stores key-value parameters of that state. Both the application&rsquo;s state and state parameters are available for injection with $state and $stateParams respectively, although, as we&rsquo;ll see, only one is necessary for injection in any given controller.</p>

<!-- more -->


<p>The <code>$state</code> service provides a number of useful methods for manipulating the state as well as pertinent data on the current state. The current state parameters are accessible on the $state service at the <code>params</code> key. The <code>$stateParams</code> service returns this very same object. Hence, the <code>$stateParams</code> service is strictly a convenience service to quickly access the <code>params</code> object on the <code>$state</code> service.</p>

<p><code>javascript
angular.equals($state.params, $stateParams)
// true
</code></p>

<p>As such, no controller should ever inject both the <code>$state</code> service and its convenience service, <code>$stateParams</code>. If the <code>$state</code> is being injected just to access the current parameters, the controller should be rewritten to inject <code>$stateParams</code> instead.</p>

<p>Let&rsquo;s take a look at a few examples to could be rewritten to minimize our injections and concerns and to generally clean up our controllers.</p>

<p><strong>Example: Only need to access state parameters</strong></p>

<p><em>Before:</em>
``` javascript
MainCtrl = (function() {
  function MainCtrl($state) {</p>

<pre><code>this.label = $state.params.active;
</code></pre>

<p>  }
})();
app.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$state&rsquo;, MainCtrl]);
```</p>

<p><em>After:</em>
``` javascript
MainCtrl = (function() {
  function MainCtrl($stateParams) {</p>

<pre><code>this.label = $stateParams.active;
</code></pre>

<p>  }
})();
app.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$stateParams&rsquo;, MainCtrl]);
```</p>

<p>In the above example, the controller only needs to access the parameters of the current state. Injecting the <code>$state</code> service is, therefore, unnecessary. Injective the convenience service here is preferred.</p>

<p><strong>Example: Need to both transition state and access params</strong></p>

<p><em>Before:</em>
``` javascript
MainCtrl = (function() {
  function MainCtrl($state, $stateParams) {</p>

<pre><code>this.label = $stateParams.active;
</code></pre>

<p>  }</p>

<p>  MainCtrl.prototype.goToBeta = function() {</p>

<pre><code>this.$state.go('beta');
</code></pre>

<p>  }
})();
app.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$state&rsquo;, &lsquo;$stateParams&rsquo;, MainCtrl]);
```</p>

<p><em>After:</em>
``` javascript
MainCtrl = (function() {
  function MainCtrl($state) {</p>

<pre><code>this.label = $state.params.active;
</code></pre>

<p>  }</p>

<p>  MainCtrl.prototype.goToBeta = function() {</p>

<pre><code>this.$state.go('beta');
</code></pre>

<p>  }
})();
app.controller(&lsquo;MainCtrl&rsquo;, [&lsquo;$state&rsquo;, MainCtrl]);
```</p>

<p>In this example, we are using the <code>$state</code> service for its methods and not just for the parameters data it holds. In this case, again, we see that we do not need to inject both services. We can stick with the <code>$state</code> service and merely access the <code>params</code> key on the service.</p>

<p>As your controllers increase in complexity, so, too, do the benefits of including one service or the other. The list of injected services acts as a signature for a controller. Keeping this list lean is imperative to ensuring the controller&rsquo;s purpose is communicated efficiently. Ensuring that only one of the $state and $stateParams services will only help your projects' overall readability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA['stringify_keys' Error on update_attributes]]></title>
    <link href="http://danubilla.com/blog/web-development/stringify-keys-error-on-update-attribute.html"/>
    <updated>2014-03-30T09:30:00-04:00</updated>
    <id>http://danubilla.com/blog/web-development/stringify-keys-error-on-update-attribute</id>
    <content type="html"><![CDATA[<p>Rails is a fantastic framework to develop with, but it can occasionally be unforgiving when it comes to error throwing. I was recently coding up a soft delete method in a model when Rails gave me the perplexing error: &ldquo;Undefined Method `stringify_keys'&rdquo;. I wasn&rsquo;t calling stringify_keys anywhere in my method nor was it anywhere in my model. A grep through the app directory of the codebase came up empty as well, and I was stumped.</p>

<!-- more -->


<p>As it turns out, the error was being thrown from deeper in the code than in my application, but it was, in fact, my code that was in error.</p>

<p><code>ruby
def remove!
  self.update_attributes(:status, 'removed')
end
</code></p>

<p>The error lies in the arguments that are being passed into update_attributes. update_attributes expects one argument, a hash, whereas, I am providing two arguments, a key and a value. The error is exactly four characters long. The corrected code is below.</p>

<p><code>ruby
def remove!
  self.update_attributes(status =&gt; 'removed')
end
</code></p>

<p>h/t to <a href="http://stackoverflow.com/questions/7542774/undefined-method-stringify-keys-when-calling-update-attributes">Stack Overflow</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a New Post for Octopress from Zsh]]></title>
    <link href="http://danubilla.com/blog/web-development/creating-a-new-post-for-octopress-from-zsh.html"/>
    <updated>2014-01-31T00:17:00-05:00</updated>
    <id>http://danubilla.com/blog/web-development/creating-a-new-post-for-octopress-from-zsh</id>
    <content type="html"><![CDATA[<p>A couple of years back, I made the switch from bash to zsh. I did so mainly because I saw <a href="" title="http://code.tutsplus.com/tutorials/how-to-customize-your-command-prompt--net-24083&quot;, &quot;Customizing Your Command Prompt on Nettuts">a fantastic post</a> on customizing the command prompt that I dove into head first, and I&rsquo;ve stuck with it for the slightly improved tab completion. Your mileage may vary with regards to zsh, but I always find it difficult to do without it when I end up working on somebody else&rsquo;s machine. Despite the improvement, there are a few differences between the shells, and I&rsquo;ve come across a scipt or two that wasn&rsquo;t especially zsh friendly. One of those is the very rake task that created this blog post.</p>

<!-- more -->


<p>To create a post in Octopress from bash, you simply need to run the command:</p>

<blockquote><p>rake new_post[&ldquo;One man forgot to account for zsh&hellip;&rdquo;]</p></blockquote>

<p>Running the same command from zsh leaves you with a cryptic error:</p>

<blockquote><p>zsh: no matches found: new_post[One man forgot to account for zsh&hellip;]</p></blockquote>

<p>Zsh escapes the quotes necessary to name the new blog post, as you can see by the error that is output. The syntax that creates a blog post in bash causes zsh to begin attempting to match a filename.</p>

<p>To create a post in Octopress from zsh, you simply need to run the command:</p>

<blockquote><p>rake &ldquo;new_post[One man forgot to account for zsh&hellip;]&rdquo;</p></blockquote>

<p>It&rsquo;s a minor inconvenience, and one that could probably be solved by some extended documentation on the Octopress site. No harm, no foul; zsh Octopress bloggers just need to remember the change in syntax.</p>

<p>Any other zsh tips for Octopress? Or any noteworthy zsh &ldquo;workarounds&rdquo; to share? Drop them in comments.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing MaxWell]]></title>
    <link href="http://danubilla.com/blog/web-development/introducing-maxwell.html"/>
    <updated>2013-09-04T11:48:00-04:00</updated>
    <id>http://danubilla.com/blog/web-development/introducing-maxwell</id>
    <content type="html"><![CDATA[<p>In my last post, Yeoman, Backbone, and a Smarter Client, I discussed diving into the new development-minded technologies that have flooded the JS proverbial toolbox. The first project I put together with said tools is <a href="http://dubilla.github.io/Maxwell/">MaxWell</a>, a single-page web app for graphing your point totals in ESPN&rsquo;s Fantasy MaxPart games (think Pigskin Pick'em and ESPN&rsquo;s march madness game, Tournament Challenge). <a href="http://yeoman.io/">Yeoman</a> and <a href="https://github.com/yeoman/generator-backbone">the Yeoman Backbone generator</a> were used to bootstrap the application. <a href="http://requirejs.org/">RequireJS</a> is used to manage dependencies. The application itself lives inside a <a href="http://backbonejs.org/">Backbone</a> framework. <a href="http://gruntjs.com/">Grunt</a> is used to build the webapp and prepare it for deployment. Finally, the app is deployed using git and it lives on <a href="http://pages.github.com/">GitHub pages</a>.</p>

<!-- more -->


<p>All in all, I could not be more pleased with the single-page web app tools I&rsquo;ve discovered and workflow I&rsquo;ve cultivated. Now that I have the workflow in place, I&rsquo;m already looking to the next side project, FoursightSquare, to see just how quickly I can spin up a web app, start iterating on it, and deploy quickly with each iteration. You can follow along in the meanwhile on its Github page.</p>

<p>It&rsquo;s important to note that MaxWell is a proof of concept with hard-coded values. Given an API, this web app could exist in its current form, or, in an API&rsquo;s absence, this app could be pushed to ESPN&rsquo;s servers and hooked up with just a little bit of server-side code.</p>
]]></content>
  </entry>
  
</feed>
